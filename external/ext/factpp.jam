# "owl_cpp/external/ext/factpp.jam"
# part of owl_cpp project.
# Distributed under the Boost Software License, Version 1.0; see doc/license.txt.
# Copyright Mikhail K Levin 2010-1

# Boost.build script for building FaCT++ library 
# <http://code.google.com/p/factplusplus/>

import extension ;

import property ;
import project ;
import feature ;
import common ;
import regex ;
import path ;
import utils ; #local jam-file

extension.declare factpp ;

rule config_hpp ( targets * : sources * : properties * ) {
   STR on $(<) =
      "#ifndef FACTPP_CONFIG_HPP"
      "#define FACTPP_CONFIG_HPP"
      ""
      "#include \"boost/config.hpp\""
      "#ifndef BOOST_SYMBOL_EXPORT"
      "  #define BOOST_SYMBOL_EXPORT"
      "  #define BOOST_SYMBOL_IMPORT"
      "#endif"
      "#if defined(FACTPP_KERNEL_DYN_LINK)"
      "#  if defined(FACTPP_KERNEL_SOURCE)"
      "#     define FACTPP_KERNEL_DECL BOOST_SYMBOL_EXPORT"
      "#  else"
      "#     define FACTPP_KERNEL_DECL BOOST_SYMBOL_IMPORT"
      "#  endif"
      "#else"
      "#  define FACTPP_KERNEL_DECL"
      "#endif"
      ""
      "#endif /* FACTPP_CONFIG_HPP */"
   ;
   
   NL on $(<) = "
" ;
}
actions config_hpp { @($(STDOUT):E=$(STR:J=$(NL))$(NL)) > "$(<)" }

rule make_hpp_cpp ( original : symbols * : includes * ) {
   make_hpp $(original) : $(symbols) ;
   includes ?= $(original) ;
   make_cpp $(original:S=.cpp) : $(includes) ;
}

## make header that includes config.h, exposes symbols, and includes original header
rule make_hpp ( original : symbols * ) {
   local base = $(original:B) ;
   make-singleton $(base)_config.hpp 
      : $(original)
      : @config_header 
      : <location>$(GENERATED_INCLUDE)/factpp <name>$(symbols)
   ;
}

## copy cpp replacing includes.* with include_config.hpp
rule make_cpp ( original : includes * ) {
   make-singleton $(original:D=)
      : $(original) $(includes)
      : @src_config 
      : <location>$(GENERATED_LIB)/factpp
   ;
}

rule config_header ( targets* : sources * : properties * ) {
   local re = "extern ([ 0-9A-Za-z*\,():&<]+;)" ;
   local file = [ utils.read_file $(sources:G=) ] ;
   file = [ SPLIT_BY_CHARACTERS $(file) : "\n" ] ;
   local extern = [ MATCH "$(re)" : $(file) ] ;
   #echo $(sources:G=) ;
   #echo $(extern) ;
   local name = [ property.select <name> : $(properties) ] ;
   local class-name = $(name:G=) ;
   local file-name = $(sources:G="":D=) ;
   local file-base = $(file-name:B) ;
   STR on $(<) = 
      "#ifndef $(file-base:U)_CONFIG_HPP"
      "#define $(file-base:U)_CONFIG_HPP"
      ""
      "#include \"factpp/config.hpp\""
      "class FACTPP_KERNEL_DECL $(class-name);"
      ""
      "#include \"$(file-name)\""
      "FACTPP_KERNEL_DECL $(extern)"
      ""
      "#endif /* $(file-base:U)_CONFIG_HPP */"
   ;
   NL on $(<) = "
" ;
}
actions config_header { @($(STDOUT):E=$(STR:J=$(NL))$(NL)) > "$(<)" }

rule replace_extern_hpp ( targets* : sources * : properties * ) {
   local incl = "
#define DLTREE_H
#include \"factpp/config.hpp\"" ;
   local src = [ utils.read_file $(sources:G=) ] ;
   src = [ regex.replace $(src) "extern" "FACTPP_KERNEL_DECL" ] ;
   src = [ regex.replace $(src) "#define DLTREE_H" $(incl) ] ;
   STR on $(<) = $(src)
   ;
   NL on $(<) = "
" ;
}
actions replace_extern_hpp { @($(STDOUT):E=$(STR)) > "$(<)" }

rule src_config ( targets * : sources * : properties * ) {
   local files = $(sources:G=) ;
   local src = [ utils.read_file $(files[1]) ] ;
   for local file in $(files[2-]) {
      src = [ regex.replace $(src) $(file:D=) "factpp/$(file:B)_config.hpp" ] ;
   }
   STR on $(<) = $(src) ;
}
actions src_config { @($(STDOUT):E=$(STR)) > "$(<)" }

rule init ( version ? : location : options * )
{
   version ?= default ;
   
   local kernel_location = [ path.join $(location) src/Kernel ] ;
   
   make-singleton config.hpp 
      : 
      :  @config_hpp
      :  <factpp-version>$(version)
         <location>$(GENERATED_INCLUDE)/factpp
   ;
   
   local convert_hpp_cpp = 
      Kernel tExpressionManager dlTBox DLConceptTaxonomy Taxonomy Reasoner tRole
      dltree
   ;
   
   local convert_hpp = $(convert_hpp_cpp) #tNamedEntry
   ;
   
   local convert_cpp = $(convert_hpp_cpp) SaveLoad Tactic CascadedCache
   ;
   
   make_hpp_cpp $(kernel_location)/Kernel.h : ReasoningKernel TNamedEntry TRole ;
   make_hpp_cpp $(kernel_location)/tExpressionManager.h : TExpressionManager ;
   make_hpp_cpp $(kernel_location)/dlTBox.h : TBox ;
   make_hpp_cpp $(kernel_location)/DLConceptTaxonomy.h : DLConceptTaxonomy ;
   make_hpp_cpp $(kernel_location)/Taxonomy.h : Taxonomy ;
   make_hpp_cpp $(kernel_location)/Reasoner.h : DlSatTester ;
   make_hpp_cpp $(kernel_location)/tRole.h : TRole ;
   make-singleton dltree_config.hpp 
      : $(kernel_location)/dltree.h
      : @replace_extern_hpp 
      : <location>$(GENERATED_INCLUDE)/factpp
   ;

   make_cpp $(kernel_location)/SaveLoad.cpp : $(kernel_location)/Kernel.h ;
   make_cpp $(kernel_location)/Tactic.cpp : $(kernel_location)/Reasoner.h ;
   make_cpp $(kernel_location)/CascadedCache.cpp : $(kernel_location)/Reasoner.h ;
   make_cpp $(kernel_location)/dltree.cpp : $(kernel_location)/dltree.h ;
   
   local src = 
      [ 
         glob $(kernel_location)/*.cpp 
         : #exclude:
            $(kernel_location)/parseTime.cpp
            $(kernel_location)/$(convert_cpp).cpp
      ]
      $(convert_cpp).cpp
   ;
   #src = Kernel.cpp tExpressionManager.cpp ;
   
   lib factpp_kernel
      :   $(src)
      :   #requirements
         [ extension.define factpp $(version) : $(kernel_location) : $(options) ]
         <include>$(kernel_location)
         <include>$(BOOST[1])
         <include>$(GENERATED_INCLUDE)
         <implicit-dependency>config.hpp
         <implicit-dependency>$(convert_hpp)_config.hpp
         <define>FACTPP_KERNEL_SOURCE
         <link>shared:<define>FACTPP_KERNEL_DYN_LINK
         <toolset>gcc:<cflags>"-fvisibility=hidden -fvisibility-inlines-hidden"
      :   
      :   
         <include>$(kernel_location)
         <include>$(GENERATED_INCLUDE)
      ;
}
